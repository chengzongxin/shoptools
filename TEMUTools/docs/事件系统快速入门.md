# 事件系统快速入门指南

## 🎯 目标

当网络请求发生403错误时，自动通知并停止所有正在运行的功能模块任务。

## ⚡ 快速开始（3步集成）

### 第1步：在你的Crawler类中添加初始化代码

```python
from ..network.event_manager import EventManager
import threading

class YourCrawler:
    def __init__(self):
        # ... 其他初始化代码 ...
        
        # ✅ 添加这3行代码
        self.event_manager = EventManager()
        self.stop_event = threading.Event()
        self.event_manager.subscribe("config_error", self._handle_config_error)
```

### 第2步：添加错误处理函数

```python
    def _handle_config_error(self, **kwargs):
        """当收到403错误通知时，设置停止信号"""
        print(f"收到配置错误通知，停止任务")
        self.stop_event.set()  # 设置停止信号
```

### 第3步：在循环中检查停止信号

```python
    def process_items(self, items):
        """处理项目列表"""
        self.stop_event.clear()  # 任务开始前清除旧信号
        
        for item in items:
            # ✅ 在每次循环时检查停止信号
            if self.stop_event.is_set():
                print("任务已停止")
                break
            
            # 处理项目...
            result = self.request.post("/api/process", {"item": item})
```

## ✨ 完成！

就这么简单！当任何地方的网络请求发生403错误时，你的模块会自动收到通知并停止。

## 📚 完整示例

```python
from ..network.request import NetworkRequest
from ..network.event_manager import EventManager
import threading

class PriceReviewCrawler:
    """核价模块示例"""
    
    def __init__(self):
        self.request = NetworkRequest()
        
        # 1. 初始化事件系统
        self.event_manager = EventManager()
        self.stop_event = threading.Event()
        self.event_manager.subscribe("config_error", self._handle_config_error)
    
    # 2. 添加错误处理函数
    def _handle_config_error(self, **kwargs):
        print(f"[核价模块] 收到配置错误通知，停止任务")
        self.stop_event.set()
    
    # 3. 在业务逻辑中检查停止信号
    def batch_review(self, products):
        self.stop_event.clear()  # 开始前清除
        
        for i, product in enumerate(products):
            if self.stop_event.is_set():  # 检查停止信号
                print(f"任务已停止，已处理 {i}/{len(products)}")
                break
            
            # 发送请求
            result = self.request.post("/api/review", {"id": product.id})
            if result is None:
                # 请求失败，如果是403错误，stop_event会被自动设置
                continue
            
            # 处理结果...
```

## 🔍 工作原理

```
1. 你的模块启动 ──→ 订阅 "config_error" 事件
2. 网络请求发生403 ──→ NetworkRequest 发布事件
3. 你的模块收到通知 ──→ 设置 stop_event
4. 循环检测到信号 ──→ 停止任务
```

## 💡 关键点

1. **使用 `threading.Event()`** - 线程安全的停止信号
2. **订阅一次即可** - 在 `__init__` 中订阅
3. **经常检查** - 在每次循环开始时检查 `stop_event.is_set()`
4. **清除信号** - 每次任务开始前调用 `stop_event.clear()`

## 📖 更多信息

- 详细说明：见 `事件通知系统使用说明.md`
- 代码示例：见 `event_system_example.py`

## ❓ 常见问题

**Q: 我的模块没有Crawler类怎么办？**  
A: 在任何需要停止的类中都可以使用，比如GUI类。

**Q: 需要手动触发事件吗？**  
A: 不需要！NetworkRequest 在遇到403错误时会自动触发。

**Q: 可以自定义其他事件吗？**  
A: 可以！使用 `event_manager.publish("你的事件名", 参数=值)` 发布自定义事件。

**Q: 影响性能吗？**  
A: 几乎没有影响，只是简单的条件判断。

