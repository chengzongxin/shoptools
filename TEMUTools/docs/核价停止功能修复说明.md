# 核价停止功能修复说明

## 问题描述

之前点击"停止"按钮后，任务仍然在后台继续运行，无法真正停止。

## 问题原因

1. **一次性提交所有任务**：使用线程池时，所有商品的处理任务在开始时就被一次性提交，即使用户点击停止，这些已提交的任务仍会继续执行。

2. **任务内部不检查停止标志**：`process_single_price_review` 方法内部没有检查停止标志，导致正在执行的任务无法被中断。

## 修复内容

### 1. 在任务处理的多个关键点添加停止检查

在 `process_single_price_review` 方法中添加了4个检查点：

```python
# 检查点1：任务开始时
if self.stop_flag_callback():
    return False, "任务已被用户停止"

# 检查点2：发送网络请求前
if self.stop_flag_callback():
    return False, "任务已被用户停止"

# 检查点3：获取核价建议后
if self.stop_flag_callback():
    return False, "任务已被用户停止"

# 检查点4：执行操作前
if self.stop_flag_callback():
    return False, "任务已被用户停止"
```

**为什么需要多个检查点？**

因为处理每个商品需要多个步骤，每个步骤可能需要几秒钟：
- 获取订单信息
- 获取核价建议（网络请求）
- 计算价格
- 执行操作（网络请求）

如果只在开始时检查一次，用户点击停止后，正在执行的任务还需要完成所有步骤才能停止。通过在多个关键点检查，可以更快速地响应停止请求。

### 2. 取消未完成的任务

在检测到停止标志时，主动取消所有未完成的任务：

```python
if self.stop_flag_callback():
    self.logger.info("用户手动停止批量处理核价")
    self.logger.info("正在取消剩余任务...")
    # 取消所有未完成的任务
    for f in future_to_product.keys():
        if not f.done():
            f.cancel()
    break
```

### 3. 初始化停止标志

在 GUI 初始化时添加停止标志的初始化：

```python
def __init__(self, parent):
    super().__init__(parent)
    # ... 其他初始化代码 ...
    
    # 初始化停止标志
    self._stop_flag = False
```

### 4. 改进停止按钮的日志输出

让用户清楚地看到停止操作正在执行：

```python
def stop_crawling(self):
    """停止爬取"""
    self._stop_flag = True
    self.logger.info("=" * 50)
    self.logger.info("用户点击停止按钮 - 正在停止任务...")
    self.logger.info("正在取消未完成的任务，请稍候...")
    self.logger.info("=" * 50)
```

### 5. 显示停止后的统计信息

任务停止后，显示已处理的进度：

```python
if self.stop_flag_callback():
    self.logger.info("=" * 50)
    self.logger.info(f"任务已停止！")
    self.logger.info(f"已处理: {len(results)}/{total_products} 个商品")
    self.logger.info(f"成功: {success_count}, 失败: {failed_count}")
    self.logger.info("=" * 50)
```

## 使用说明

1. **点击"开始批量核价"**：程序开始处理待核价商品
2. **点击"停止"按钮**：
   - 日志区域会立即显示"正在停止任务..."
   - 正在执行的任务会在下一个检查点停止
   - 未开始的任务会被取消
   - 显示已处理的进度统计

## 预期效果

- ✅ 点击停止后，**1-3秒内**任务会完全停止（取决于网络请求耗时）
- ✅ 未开始的任务**不会被执行**
- ✅ 正在执行的任务会在**下一个检查点**停止
- ✅ 显示**清晰的停止信息**和进度统计

## 注意事项

1. **不是瞬间停止**：由于需要等待当前的网络请求完成，停止操作可能需要1-3秒
2. **部分商品已处理**：停止时，部分商品可能已经完成处理，这是正常的
3. **线程安全**：使用了 `stop_flag_callback()` 确保多线程环境下的安全性

## 测试建议

1. 启动批量核价任务（建议设置5个线程）
2. 等待3-5秒后点击停止按钮
3. 观察日志输出，确认任务停止
4. 检查进度统计，确认只处理了部分商品

## 编程知识点

### 1. 多线程任务取消

```python
# 取消未完成的Future对象
for future in futures:
    if not future.done():  # 检查任务是否完成
        future.cancel()     # 取消未开始的任务
```

### 2. 回调函数（Callback）

```python
# 传递一个函数作为参数
self.stop_flag_callback = lambda: self._stop_flag

# 在其他地方调用
if self.stop_flag_callback():  # 调用这个函数检查标志
    # 停止操作
```

回调函数就像"电话号码"，你把号码给别人，别人需要的时候就打电话给你。

### 3. 线程池（ThreadPoolExecutor）

```python
with ThreadPoolExecutor(max_workers=5) as executor:
    # 提交任务
    futures = [executor.submit(func, arg) for arg in args]
    
    # 处理完成的任务
    for future in as_completed(futures):
        result = future.result()  # 获取结果
```

线程池就像一个"工人队伍"，你给他们分配任务，他们并发执行。

### 4. 为什么需要多个检查点？

想象一下：
- 你在跑步（执行任务）
- 教练喊停（点击停止按钮）
- 如果只在起点检查教练是否喊停，你可能已经跑了100米才回到起点检查
- 如果每跑25米就检查一次，你能更快停下来

代码也是一样的道理！每个网络请求可能需要1-2秒，如果只在开始检查一次，用户点停止后还要等所有请求完成。通过在多个位置检查，可以更快响应。

## 总结

通过添加多个检查点和主动取消未完成任务，现在的停止功能可以在1-3秒内完全停止任务，大大改善了用户体验。

这是一个很好的编程实践：**在长时间运行的任务中，定期检查是否需要中断**。

