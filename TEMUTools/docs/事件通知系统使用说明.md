# 事件通知系统使用说明

## 概述

当网络请求发生403错误时（通常是Cookie过期或MallID配置错误），系统会自动发布一个 `config_error` 事件，通知所有订阅的模块停止当前任务。

这个机制使用了**观察者模式**（也叫发布-订阅模式），让不同模块之间可以解耦通信。

## 工作原理

### 简单比喻
想象一下广播系统：
- **发布者**（NetworkRequest）= 广播电台，发现错误时发送广播
- **事件管理器**（EventManager）= 广播系统，负责传递消息
- **订阅者**（各个功能模块）= 收音机，接收到广播后执行相应动作

### 技术流程
```
1. 功能模块启动时 → 订阅 "config_error" 事件
2. 网络请求发生403错误 → 发布 "config_error" 事件
3. 事件管理器 → 通知所有订阅者
4. 各功能模块 → 收到通知后停止任务
```

## 使用方法

### 方式一：在Crawler类中使用（推荐）

如果你的模块有一个爬虫类（Crawler），可以在类的初始化方法中订阅事件：

```python
from ..network.request import NetworkRequest
from ..network.event_manager import EventManager

class PriceReviewCrawler:
    """核价模块的爬虫类"""
    
    def __init__(self):
        # 初始化网络请求对象
        self.request = NetworkRequest()
        
        # 初始化事件管理器
        self.event_manager = EventManager()
        
        # 任务停止标志
        self.should_stop = False
        
        # 订阅配置错误事件
        self.event_manager.subscribe("config_error", self.on_config_error)
    
    def on_config_error(self, **kwargs):
        """
        当收到配置错误事件时的处理函数
        
        参数:
            error_code: 错误代码（403）
            error_message: 错误消息
            request_type: 请求类型（GET/POST/PUT/DELETE）
        """
        print(f"[核价模块] 收到配置错误通知，准备停止任务")
        print(f"错误代码: {kwargs.get('error_code')}")
        print(f"请求类型: {kwargs.get('request_type')}")
        
        # 设置停止标志
        self.should_stop = True
        
        # 这里可以添加其他清理工作
        # 比如：关闭文件、保存进度等
    
    def process_products(self, products):
        """
        处理产品列表
        """
        for i, product in enumerate(products):
            # 在处理每个产品之前，检查是否需要停止
            if self.should_stop:
                print(f"[核价模块] 任务已停止，已处理 {i} 个产品")
                break
            
            # 处理产品
            result = self.request.post("/api/product/review", {"productId": product.id})
            
            # 如果请求失败（比如403错误），result会是None
            if result is None:
                # 这时事件已经被发布，should_stop会被设置为True
                # 在下一次循环时会自动停止
                print(f"[核价模块] 处理产品 {product.id} 失败")
                continue
            
            # 继续处理...
```

### 方式二：在GUI类中使用

如果你的模块有一个GUI类，可以在按钮点击事件中订阅：

```python
import tkinter as tk
from ..network.event_manager import EventManager

class PriceReviewGUI:
    """核价模块的GUI类"""
    
    def __init__(self, root):
        self.root = root
        self.crawler = PriceReviewCrawler()
        self.event_manager = EventManager()
        
        # 订阅配置错误事件
        self.event_manager.subscribe("config_error", self.on_config_error)
        
        # 创建界面...
        self.status_label = tk.Label(root, text="就绪")
        self.status_label.pack()
    
    def on_config_error(self, **kwargs):
        """处理配置错误事件"""
        # 更新界面状态
        self.status_label.config(text="任务已停止：配置错误", fg="red")
        
        # 通知爬虫停止
        self.crawler.should_stop = True
        
        print(f"[核价GUI] 收到配置错误通知")
```

### 方式三：使用线程安全的停止标志

如果你的任务运行在多线程中，可以使用 `threading.Event` 配合事件系统：

```python
import threading
from ..network.event_manager import EventManager

class PriceReviewCrawler:
    def __init__(self):
        self.request = NetworkRequest()
        self.event_manager = EventManager()
        
        # 使用threading.Event作为停止信号（线程安全）
        self.stop_event = threading.Event()
        
        # 订阅配置错误事件
        self.event_manager.subscribe("config_error", self.on_config_error)
    
    def on_config_error(self, **kwargs):
        """配置错误时设置停止信号"""
        print(f"[核价模块] 收到配置错误通知，设置停止信号")
        self.stop_event.set()  # 设置停止信号
    
    def process_products_in_thread(self, products):
        """在线程中处理产品"""
        for product in products:
            # 检查停止信号
            if self.stop_event.is_set():
                print(f"[核价模块] 检测到停止信号，停止处理")
                break
            
            # 处理产品...
            time.sleep(1)  # 模拟处理
```

## 完整示例：修改现有的核价模块

下面是一个完整的示例，展示如何修改 `price_review/crawler.py`：

```python
# src/modules/price_review/crawler.py

from ..network.request import NetworkRequest
from ..network.event_manager import EventManager
import threading

class PriceReviewCrawler:
    def __init__(self):
        # ... 其他初始化代码 ...
        
        # 初始化事件管理器
        self.event_manager = EventManager()
        
        # 任务停止信号（线程安全）
        self.stop_event = threading.Event()
        
        # 订阅配置错误事件
        self.event_manager.subscribe("config_error", self._handle_config_error)
    
    def _handle_config_error(self, **kwargs):
        """
        处理配置错误事件
        当网络请求发生403错误时，这个方法会被自动调用
        """
        error_code = kwargs.get('error_code', 'Unknown')
        request_type = kwargs.get('request_type', 'Unknown')
        
        print(f"[核价模块] 收到配置错误通知")
        print(f"  错误代码: {error_code}")
        print(f"  请求类型: {request_type}")
        print(f"[核价模块] 正在停止所有任务...")
        
        # 设置停止信号
        self.stop_event.set()
    
    def fetch_products_to_review(self):
        """获取待核价商品列表"""
        # 在所有可能的长时间操作前，先检查是否需要停止
        if self.stop_event.is_set():
            print("[核价模块] 任务已停止")
            return []
        
        # ... 原有的获取商品代码 ...
    
    def review_product(self, product):
        """核价单个商品"""
        # 检查停止信号
        if self.stop_event.is_set():
            print(f"[核价模块] 任务已停止，跳过商品 {product.id}")
            return None
        
        # 发送核价请求
        result = self.request.post("/api/review", {"productId": product.id})
        
        # 如果是403错误，result会是None，并且stop_event会被设置
        if result is None:
            print(f"[核价模块] 请求失败，商品 {product.id}")
            return None
        
        return result
    
    def batch_review(self, products):
        """批量核价"""
        # 在开始批量任务前，清除之前的停止信号
        self.stop_event.clear()
        
        success_count = 0
        fail_count = 0
        
        for i, product in enumerate(products):
            # 每次循环都检查停止信号
            if self.stop_event.is_set():
                print(f"[核价模块] 任务被中断，已处理 {i}/{len(products)} 个商品")
                break
            
            print(f"[核价模块] 处理商品 {i+1}/{len(products)}")
            
            # 处理商品
            result = self.review_product(product)
            if result:
                success_count += 1
            else:
                fail_count += 1
        
        print(f"[核价模块] 任务完成")
        print(f"  成功: {success_count}")
        print(f"  失败: {fail_count}")
        
        return success_count, fail_count
```

## 取消订阅

当模块不再需要监听事件时，应该取消订阅（虽然大多数情况下不需要）：

```python
def cleanup(self):
    """清理资源"""
    # 取消订阅
    self.event_manager.unsubscribe("config_error", self._handle_config_error)
```

## 注意事项

1. **单例模式**：`EventManager` 使用单例模式，整个应用程序共享一个实例
2. **线程安全**：使用 `threading.Event()` 来实现线程安全的停止信号
3. **及时检查**：在长时间运行的循环中，应该经常检查停止信号
4. **错误处理**：即使回调函数出错，也不会影响其他模块的通知
5. **参数传递**：事件发布时可以传递额外参数，订阅者通过 `**kwargs` 接收

## 可用的事件

目前系统中定义的事件：

| 事件名称 | 触发条件 | 传递参数 |
|---------|---------|---------|
| `config_error` | 网络请求发生403错误 | `error_code`: 错误代码<br>`error_message`: 错误消息<br>`request_type`: 请求类型 |

## 扩展：自定义事件

你也可以在自己的模块中发布自定义事件：

```python
from ..network.event_manager import EventManager

# 发布自定义事件
event_manager = EventManager()
event_manager.publish("task_completed", task_id=123, result="success")

# 在其他地方订阅
def on_task_completed(task_id, result):
    print(f"任务 {task_id} 完成，结果: {result}")

event_manager.subscribe("task_completed", on_task_completed)
```

## 总结

使用这个事件系统的好处：
- ✅ **解耦**：各模块不需要直接依赖，通过事件通信
- ✅ **灵活**：可以随时添加新的订阅者，不需要修改发布者代码
- ✅ **可靠**：某个订阅者出错不会影响其他订阅者
- ✅ **易用**：只需三步：初始化、订阅、检查停止信号

